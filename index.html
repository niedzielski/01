<html>
  <head>
    <meta name=viewport content='width=device-width, initial-scale=1' />
    <title>01</title>
    <style>
      body {
        background: #000;

        /* Make the body flush with the window. */
        margin: 0;

        /* Clip the body to the window and suppress scrollbars. The canvas is
           scaled to the greatest *integer* multiple required to fill both width
           and height. The window is exceeded on one or both sides when it's not
           a square integer multiple. An integer is used to maintained pixel
           proportions. */
        overflow: hidden;
      }
      canvas {
        /* Center the clipped canvas which often overflows the window. */
        margin-left: 50%;
        transform: translateX(-50%);

        /* Scale using nearest-neighbor and proportional integer multiples to
           keep rendering pixel perfect. */
        image-rendering: optimizeSpeed;
        image-rendering: pixelated;
      }
    </style>
  </head>
  <body>
    <canvas></canvas>

    <script id=vert type=x-shader>
      #version 300 es
      precision lowp float;
      precision lowp int;

      // Should match JavaScript RESOLUTION. The rendering resolution is fixed
      // although the canvas dimensions and CSS scale may change.
      const vec2 RESOLUTION = vec2(64, 64); // x, y (px)

      // Must match JavaScript ATTRIB_LOCATION.
      layout(location = 0) in vec2 texCoord; // x, y (px)
      layout(location = 1) in vec4 subTexCoord; // x, y, w, h (px)
      layout(location = 2) in vec2 scale; // x, y
      // 0-255 (an integer is used for simple buffering).
      layout(location = 3) in float minusAlpha;
      layout(location = 4) in vec2 position; // x, y (px)

      out vec2 vTexCoord; // x, y (px)
      out float vMinusAlpha; // 0-1

      void main() {
        // Values are in pixel units. Compute the pixel position of the scaled
        // subtexture.
        vec2 px = texCoord * subTexCoord.zw * scale + position;

        // Convert the pixels to clip space by taking them to be fraction of the
        // total resolution, translating them to -1 to 1, and flipping the y
        // -coordinate so positive y is downward.
        vec2 clip = (2. * px / RESOLUTION - 1.) * vec2(1, -1);
        gl_Position = vec4(clip, 0, 1);

        // Output the computed sub-texture coordinate and -alpha.
        vTexCoord = subTexCoord.xy + texCoord * subTexCoord.zw;
        vMinusAlpha = minusAlpha / 255.;
      }
    </script>

    <script id=frag type=x-shader>
      #version 300 es
      precision lowp float;
      precision lowp int;
      precision lowp sampler2D;

      uniform sampler2D uSampler;
      uniform vec2 uAtlasSize; // x, y (px)

      in vec2 vTexCoord;
      in float vMinusAlpha;

      out vec4 frag;

      void main() {
        vec4 color = texture(uSampler, vTexCoord / uAtlasSize);
        frag = vec4(color.rgb, color.a - vMinusAlpha);
      }
    </script>

    <script>
      const RESOLUTION = 64 // px
      const BYTE = WebGLRenderingContext.BYTE
      const UNSIGNED_BYTE = WebGLRenderingContext.UNSIGNED_BYTE
      const BYTE_SIZE = Int8Array.BYTES_PER_ELEMENT
      const UNSIGNED_BYTE_SIZE = Uint8Array.BYTES_PER_ELEMENT
      const ATTRIB_LAYOUT = { // Must match shader and buffer layouts.
        vert: {
          stride: 2,
          texCoord: {
            location: 0,
            type: BYTE,
            size: BYTE_SIZE,
            length: 2,
            stride: 2,
            offset: 0,
            divisor: 0
          }
        },
        instance: {
          stride: 9,
          subTexCoord: {
            location: 1,
            type: BYTE,
            size: BYTE_SIZE,
            length: 4,
            stride: 9,
            offset: 0,
            divisor: 1
          },
          scale: {
            location: 2,
            type: BYTE,
            size: BYTE_SIZE,
            length: 2,
            stride: 9,
            offset: 4,
            divisor: 1
          },
          minusAlpha: {
            location: 3,
            type: UNSIGNED_BYTE,
            size: UNSIGNED_BYTE_SIZE,
            length: 1,
            stride: 9,
            offset: 6,
            divisor: 1
          },
          position: {
            location: 4,
            type: BYTE,
            size: BYTE_SIZE,
            length: 2,
            stride: 9,
            offset: 7,
            divisor: 1
          }
        }
      }
      const DIMENSIONS = 2 // "2D"
      const TILE_LENGTH = 3 // width / height (px)
      const ATLAS_PNG_URI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAADCAMAAAB21NVEAAAACVBMVEUAAAAA/wAAAABJBy5MAAAAA3RSTlMA//9EUNYhAAAAGElEQVQImWNgZGRkYGRgYmJiYGSCs2BiAAHXACALOlztAAAAAElFTkSuQmCC'
      const SUB_TEX_COORD = { // px
        zero: {x: 0, y: 0},
        one: {x: 3, y: 0},
        // A full-screen black translucent texture used to gradually clear the
        // screen in several passes.
        clear: {x: 6, y: 0}
      }
      const INSTANCE_TYPE = {zero: 'zero', one: 'one', clear: 'clear'}
      const SPAWN = {
        min: {
          minusAlpha: 0x00, // 0-255
          x: -TILE_LENGTH, // px
          y: -RESOLUTION, // px
          velocity: 4, // px / s
        },
        max: {
          minusAlpha: 255 - 1, // 0-255
          x: RESOLUTION + 2 * TILE_LENGTH, // px
          y: 0, // px
          velocity: 16 // px / s
        },
        total: 256 // instances of 0s and 1s (+ 1 instance for clearing).
      }
      const CLEAR_MINUS_ALPHA = 255 - 8 // 0-255

      function loadShader(gl, program, type, id) {
        const shader = gl.createShader(type)
        const src = document.querySelector(`#${id}`).textContent.trim()
        gl.shaderSource(shader, src)
        gl.compileShader(shader)
        const log = gl.getShaderInfoLog(shader)
        if (log) console.error(log)
        gl.attachShader(program, shader)
        return shader
      }

      function scaleCanvas(canvas) {
        // The integer scale that will ensure the product of resolution in
        // either dimension meets or exceeds the corresponding window
        // dimension's length. An integer multiple is used to keep pixel perfect
        // rendering.
        const scale = Math.ceil(Math.max(window.innerWidth, window.innerHeight) / RESOLUTION)
        canvas.style.width = `${scale * RESOLUTION}px`
        canvas.style.height = `${scale * RESOLUTION}px`
      }

      function onContextRestored(gl, state) {
        console.log('GL context restored.')
        scaleCanvas(gl.canvas)
        const glState = initGL(gl, state)
        state.requestId = requestAnimationFrame(
          now => loop(glState, state, now, now)
        )
      }

      function onContextLost(canvas, state, event) {
        console.log('GL context lost.')
        event.preventDefault()
        cancelAnimationFrame(state.requestId)

        // This seems to be necessary to prevent the canvas from scaling to a
        // blurry antialiased mess on context restore.
        // todo: this is still an issue if the window is resized during pause :-[
        canvas.style.width = ''
      }

      function rnd(min, max) { return min + Math.random() * (max - min) }
      function rndInt(min, max) { return Math.floor(rnd(min, max + 1)) }

      function spawn() {
        return {
          type: rndInt(0, 1) ? INSTANCE_TYPE.zero : INSTANCE_TYPE.one,
          scale: {x: 1, y: 1},
          minusAlpha: rnd(SPAWN.min.minusAlpha, SPAWN.max.minusAlpha),
          x: rnd(SPAWN.min.x, SPAWN.max.x), // px
          y: rnd(SPAWN.min.y, SPAWN.max.y), // px
          velocity: rnd(SPAWN.min.velocity, SPAWN.max.velocity) // px / s
        }
      }

      function updateInstanceData(data, instance, i) {
        const offset = i * ATTRIB_LAYOUT.instance.stride
        data[offset + 0] = SUB_TEX_COORD[instance.type].x
        data[offset + 1] = SUB_TEX_COORD[instance.type].y
        data[offset + 2] = TILE_LENGTH
        data[offset + 3] = TILE_LENGTH
        data[offset + 4] = instance.scale.x
        data[offset + 5] = instance.scale.y
        data[offset + 6] = instance.minusAlpha
        data[offset + 7] = instance.x
        data[offset + 8] = instance.y
        return data
      }

      function glBuffer(gl, buffer, data) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW)
        gl.bindBuffer(gl.ARRAY_BUFFER, null)
      }

      function initVertexAttrib(gl, layout, buffer) {
        gl.enableVertexAttribArray(layout.location)
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.vertexAttribPointer(
          layout.location,
          layout.length,
          layout.type,
          false,
          layout.stride,
          layout.offset
        )
        gl.vertexAttribDivisor(layout.location, layout.divisor)
        gl.bindBuffer(gl.ARRAY_BUFFER, null)
      }

      function update(state, seconds) {
        state.instances.forEach((instance, i) => {
          instance.y += seconds * instance.velocity // y += s * px / s
          if (instance.y > RESOLUTION) state.instances[i] = spawn()
          updateInstanceData(state.attribData.instance, state.instances[i], i)
        })
      }

      function render({gl, vertexArray, instanceBuffer}, state) {
        gl.bindVertexArray(vertexArray)

        glBuffer(gl, instanceBuffer, state.attribData.instance)

        const length = state.attribData.vert.length / DIMENSIONS
        gl.drawArraysInstanced(gl.TRIANGLE_STRIP, 0, length, state.instances.length)

        gl.bindVertexArray(null)
      }

      function loop(glState, state, then, now) {
        // A fraction / multiple of a second.
        const seconds = (now - then) / 1000

        then = now
        state.requestId = requestAnimationFrame(
          now => loop(glState, state, then, now)
        )

        update(state, seconds)
        render(glState, state)
      }

      function initGL(gl, state) {
        gl.enable(gl.BLEND)
        gl.blendEquation(gl.FUNC_ADD)
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

        const program = gl.createProgram()
        const vertShader = loadShader(gl, program, gl.VERTEX_SHADER, 'vert')
        const fragShader = loadShader(gl, program, gl.FRAGMENT_SHADER, 'frag')
        gl.linkProgram(program)
        gl.useProgram(program)

        gl.detachShader(program, fragShader)
        gl.detachShader(program, vertShader)
        gl.deleteShader(fragShader)
        gl.deleteShader(vertShader)

        const uSampler = gl.getUniformLocation(program, 'uSampler')
        const uAtlasSize = gl.getUniformLocation(program, 'uAtlasSize')
        gl.uniform1i(uSampler, 0)
        gl.uniform2f(
          uAtlasSize, state.atlas.naturalWidth, state.atlas.naturalHeight
        )

        gl.activeTexture(gl.TEXTURE0)
        const texture = gl.createTexture()
        gl.bindTexture(gl.TEXTURE_2D, texture)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
        gl.texImage2D(
          gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, state.atlas
        )

        const vertBuffer = gl.createBuffer()
        glBuffer(gl, vertBuffer, state.attribData.vert)
        const instanceBuffer = gl.createBuffer()

        const vertexArray = gl.createVertexArray()
        gl.bindVertexArray(vertexArray)
        initVertexAttrib(gl, ATTRIB_LAYOUT.vert.texCoord, vertBuffer)
        initVertexAttrib(gl, ATTRIB_LAYOUT.instance.subTexCoord, instanceBuffer)
        initVertexAttrib(gl, ATTRIB_LAYOUT.instance.scale, instanceBuffer)
        initVertexAttrib(gl, ATTRIB_LAYOUT.instance.minusAlpha, instanceBuffer)
        initVertexAttrib(gl, ATTRIB_LAYOUT.instance.position, instanceBuffer)
        gl.bindVertexArray(null)

        return {gl, program, vertexArray, vertBuffer, instanceBuffer}
      }

      function onAtlasLoaded(gl, state) {
        const glState = initGL(gl, state)

        gl.canvas.addEventListener(
          'webglcontextlost', event => onContextLost(canvas, state, event)
        )
        gl.canvas.addEventListener(
          'webglcontextrestored', () => onContextRestored(gl, state)
        )

        const extension = gl.getExtension('WEBGL_lose_context')
        if (extension) {
          addEventListener('keyup', event => {
            if (event.key !== 'p') return
            if (gl.isContextLost()) extension.restoreContext()
            else extension.loseContext()
          })
        }

        state.requestId = requestAnimationFrame(
          now => loop(glState, state, now, now)
        )
      }

      const canvas = window.document.querySelector('canvas')
      canvas.width = RESOLUTION
      canvas.height = RESOLUTION
      scaleCanvas(canvas)
      addEventListener('resize', () => scaleCanvas(canvas))

      const gl = canvas.getContext('webgl2', {
        alpha: false,
        depth: false,
        antialias: false,
        preferLowPowerToHighPerformance: true,

        // Don't clear the screen. A full-screen black translucent texture is
        // drawn each render.
        preserveDrawingBuffer: true
      })
      if (!gl) alert('WebGL 2 is unsupported by this browser :-[')
      gl.viewport(0, 0, RESOLUTION, RESOLUTION)

      const state = {requestId: undefined}
      state.instances = Array.from(Array(SPAWN.total)).map(spawn)

      // Clear the background in the first render pass by adding the clear type
      // to the front of the instances.
      state.instances.unshift({
        x: 0,
        y: 0,
        scale: {
          x: Math.ceil(RESOLUTION / TILE_LENGTH),
          y: Math.ceil(RESOLUTION / TILE_LENGTH)
        },
        minusAlpha: CLEAR_MINUS_ALPHA,
        velocity: 0,
        type: INSTANCE_TYPE.clear
      })

      state.attribData = {
        vert: new Int8Array([ // Only texCoords are per vertex.
          1, 1,
          0, 1,
          1, 0,
          0, 0
        ]),
        instance: state.instances.reduce(
          updateInstanceData,
          new Int8Array(state.instances.length * ATTRIB_LAYOUT.instance.stride)
        )
      }

      state.atlas = new Image()
      state.atlas.onerror = () => { throw new Error('Failed to load atlas.') }
      state.atlas.onload = () => onAtlasLoaded(gl, state)
      state.atlas.src = ATLAS_PNG_URI
    </script>
  </body>
</html>
